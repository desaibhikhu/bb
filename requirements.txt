https://codeload.github.com/KurimuzonAkuma/pyrogram/zip/refs/heads/dev
pyrofork==2.3.38
TgCrypto
pyromod
humanize
schedule
APscheduler
# --- For-Database ------------ #
pymongo
motor
dnspython
# --- For-Web-Response ------- #
aiohttp
python-dotenv
# --- For-Web-Response ------- #
pytz
requests
bs4
shortzy
aiofiles
asyncio
imdb



def natural_sort(file_list):
    """Sorts file names naturally (e.g., img1, img2, img10 instead of img1, img10, img2)."""
    return sorted(file_list, key=lambda f: [int(text) if text.isdigit() else text.lower() for text in re.split(r'(\d+)', f)])

@Bot.on_message(filters.command("pdf") & filters.private & filters.user(ADMINS))
async def pdf_handler(bot: Client, message: Message):
    await message.reply_text("üìÇ Please send a ZIP file containing images. You have 30 seconds.")

    try:
        zip_msg = await bot.listen(
            message.chat.id, 
            filters.document & filters.create(lambda _, __, m: m.document and m.document.file_name.endswith(".zip")),
            timeout=30
        )
    except asyncio.TimeoutError:
        return await message.reply_text("‚è∞ Timeout: No ZIP file received within 30 seconds.")

    zip_name = os.path.splitext(zip_msg.document.file_name)[0]
    zip_path = f"downloads/{zip_msg.document.file_name}"
    extract_folder = f"downloads/{zip_name}_extracted"

    await zip_msg.download(zip_path)

    try:
        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            zip_ref.extractall(extract_folder)
    except zipfile.BadZipFile:
        return await message.reply_text("‚ùå Invalid ZIP file.")

    # Supported image formats
    valid_extensions = (".png", ".jpg", ".jpeg", ".webp", ".bmp", ".gif", ".tiff", ".img")

    # Get image files, sorted naturally
    image_files = natural_sort([
        os.path.join(extract_folder, f) for f in os.listdir(extract_folder)
        if f.lower().endswith(valid_extensions)
    ])

    if not image_files:
        return await message.reply_text("‚ùå No images found in the ZIP.")

    pdf_path = f"downloads/{zip_name}.pdf"

    try:
        first_image = Image.open(image_files[0]).convert("RGB")
        image_list = (Image.open(img).convert("RGB") for img in image_files[1:])  # Generator for memory efficiency
        first_image.save(pdf_path, save_all=True, append_images=image_list)
    except Exception as e:
        return await message.reply_text(f"‚ùå Error converting to PDF: {e}")

    await message.reply_document(pdf_path, caption=f"Here is your PDF: {zip_name}.pdf üìÑ")

    # Cleanup
    os.remove(zip_path)
    os.remove(pdf_path)
    shutil.rmtree(extract_folder, ignore_errors=True)